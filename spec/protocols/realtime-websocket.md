# Realtime WebSocket Protocol

## Endpoint

- URL: `wss://<host>/ws/realtime-asr`
- Transport: WebSocket, JSON encoded payloads per message.
- Authentication: Not handled at the transport layer; upstream infrastructure is expected to gate access.

## Connection Lifecycle

1. **Connect** – Client opens a WebSocket connection and must be prepared to receive initial `ack` and `status` messages.
2. **Streaming** – Client sends ASR-derived payloads and optional control commands while handling server acknowledgements and statuses.
3. **Close** – Either party may close the socket. The server announces closure intent via `status` stage `closed` when the `stop` control action is accepted.

## Message Envelope

All messages are JSON objects containing at minimum a `type` field. Additional fields depend on the message category.

```jsonc
{
  "type": "<message-category>",
  "session_id": "<server-provided session identifier>",
  ... // type-specific fields
}
```

Clients should echo the most recent `session_id` received from the server. The server treats a new `session_id` supplied by the client as a request to switch context to that identifier.

## Client → Server Messages

| Type          | Description                                                   | Required Fields                                        |
| ------------- | ------------------------------------------------------------- | ------------------------------------------------------ |
| `keepalive`   | Optional heartbeat payload.                                   | —                                                      |
| `control`     | Adjusts the session lifecycle.                                | `action`: one of `pause`, `resume`, `stop`.            |
| `asr_chunk`   | Sends incremental ASR output.                                 | `text`: string, `is_final`: boolean.                   |

### `control`

- `pause`: server transitions into `paused` stage and ignores further `asr_chunk` payloads until resumed.
- `resume`: server re-enters the `listening` stage.
- `stop`: server emits a `status` message with stage `closed` and then terminates the session loop.

### `asr_chunk`

- `text`: Transcript fragment from ASR.
- `is_final`: Marks whether the fragment is a finalized utterance. Only final chunks are buffered for question detection.

## Server → Client Messages

| Type        | Description                                                                 | Key Fields                                                                                           |
| ----------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| `ack`       | Confirms receipt of a message or initial connection.                        | `message` (on connect) or `received_type`, `session_id`.                                             |
| `status`    | Communicates the state machine stage.                                       | `stage`: `listening`, `paused`, `waiting_for_question`, `analyzing`, `querying_rag`, `idle`, `closed`; optional `note`, `question`. |
| `answer`    | Streams generated answers back to the client.                               | `stream_index`: integer, `content`: string chunk, `final`: boolean.                                  |
| `error`     | Signals malformed inputs or operational failures.                           | `code`: string, `message`: human-readable description, optional diagnostic fields.                   |

## Question Detection Flow

1. Client sends `asr_chunk` messages until a message with `is_final: true` arrives.
2. Server aggregates all finalized chunks and applies heuristics via `SessionState.looks_like_question()`.
3. If the aggregated text is not considered a question, the server replies with `status` stage `waiting_for_question`.
4. If recognised as a question, the server emits `status` stages `analyzing` and `querying_rag` and forwards the text to the Dify API.
5. Answer text is chunked using `stream_answer` and returned as ordered `answer` messages.
6. A concluding `status` stage `idle` indicates readiness for further input.

## Error Conditions

- **Invalid JSON**: The server responds with `error` code `INVALID_JSON` and ignores the payload.
- **Missing or Invalid Fields**: `error` code `INVALID_MESSAGE` for absent `type`, `text`, or improper types.
- **Unsupported Type**: `error` code `UNSUPPORTED_TYPE` when the `type` is not recognised.
- **Unknown Control Action**: `error` code `UNKNOWN_ACTION` when `action` is outside the supported set.
- **Backend Failures**: When the Dify API fails, the server returns an `answer` containing a descriptive error string followed by `status` stage `idle`.

## Session Management

- The initial `ack` delivers the authoritative `session_id` generated by the server.
- Clients may request a session switch by including a different `session_id`; the server will honour it by creating a new `SessionState` instance.
- Paused sessions maintain accumulated text but skip processing new chunks until resumed.

## Timing & Retries

- Clients should employ their own heartbeat logic (e.g., periodic `keepalive`) if they need explicit liveness guarantees; the server simply acknowledges these without further side effects.
- Reconnection should be handled by clients at the transport layer. Upon reconnect, a new session will be issued.

## Security Considerations

- Secrets for Dify access are injected via environment variables and never transmitted over the WebSocket.
- Consumers should run the service behind TLS termination to protect ASR content.

## Flow Diagram

```mermaid
flowchart TD
    connect[Client opens WebSocket to /ws/realtime-asr] --> ack[Server sends ack with session_id]
    ack --> listen_status[Server broadcasts status:listening]
    listen_status --> input_choice{Client message}
    input_choice -->|keepalive| ack_keepalive[Server ack keepalive]
    input_choice -->|control:pause| status_paused[Server status:paused]
    status_paused -->|control:resume| listen_status
    input_choice -->|control:stop| status_closed[Server status:closed then closes socket]
    input_choice -->|asr_chunk (is_final=false)| buffer_partial[Server buffers interim text]
    input_choice -->|asr_chunk (is_final=true)| check_question{Looks like question?}
    check_question -->|No| status_wait[Server status:waiting_for_question]
    status_wait --> listen_status
    check_question -->|Yes| status_analyzing[Server status:analyzing]
    status_analyzing --> status_query[Server status:querying_rag]
    status_query --> rag_call[Server sends text to RAG backend]
    rag_call --> answer_stream[Server streams answer chunks]
    answer_stream --> status_idle[Server status:idle]
    status_idle --> listen_status
```

The diagram captures the nominal streaming loop, highlighting how control commands influence the session stage and how final ASR
chunks trigger question analysis, RAG querying, and answer streaming before returning to the listening state.
